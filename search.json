[{"path":"https://kwstat.github.io/connected/articles/introduction_to_the_connected_package.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to the 'connected' package","text":"connected package arose experience analyzing data linear models linear mixed models. Sometimes models failed converge, reason convergence investigated, sometimes turned either data connected else weakly connected. main functions connected package : con_check() con_concur() con_view() con_filter()","code":""},{"path":"https://kwstat.github.io/connected/articles/introduction_to_the_connected_package.html","id":"visualizing-two-way-connectedness-with-con_view","dir":"Articles","previous_headings":"","what":"Visualizing two-way connectedness with con_view()","title":"Introduction to the 'connected' package","text":"illustrate idea connectedness, consider following example data Fernando et al. (1983) inspired cattle industry 2 factors: genotype herd. row represents one animal herd. Although data response variable, can simulate response variable see data analyzed linear model 2 factors. warnings, looking model coefficients shows estimate effect herd H4 estimable. happens model matrix full rank. understand , look following graphical view data levelplot:  con_view() function following: Plots levelplot/heatmap two factors, cell color corresponding value response variable. Counts number cells row puts count right axis. Column counts added along top axis. Sorts rows columns (default) according clustering incidence matrix based presence/absence data cell graph. Checks connectivity two factors. observations connected, cells belonging connected subset identified number. graphical view shows us herds H1 H3 levels genotype factor common herds H2 H4, makes sense herd effects estimable. Another way examine connectedness calculate ‘concurrence’ matrix plot :","code":"library(connected) data_fernando #>   gen herd #> 1  G2   H1 #> 2  G1   H1 #> 3  G1   H3 #> 4  G6   H3 #> 5  G3   H2 #> 6  G4   H2 #> 7  G5   H2 #> 8  G5   H4 #> 9  G7   H4 set.seed(42) data_fernando <- transform(data_fernando, y = rnorm(nrow(data_fernando), mean=100)) m1 <- lm(y ~ gen + herd, data=data_fernando) m1 #>  #> Call: #> lm(formula = y ~ gen + herd, data = data_fernando) #>  #> Coefficients: #> (Intercept)        genG2        genG3        genG4        genG5        genG6   #>     99.4353       1.9357      -0.6372      -1.1476       0.4700       0.2697   #>       genG7       herdH2       herdH3       herdH4   #>      2.5831       1.6062       0.9278           NA con_view(data_fernando, y ~ gen * herd, main=\"data_fernando\") #> Warning in con_view(data_fernando, y ~ gen * herd, main = \"data_fernando\"): #> There are 2 groups con_concur(data_fernando, y ~ gen/herd, main=\"data_fernando\")"},{"path":"https://kwstat.github.io/connected/articles/introduction_to_the_connected_package.html","id":"checking-multi-way-connectedness-with-con_check","dir":"Articles","previous_headings":"","what":"Checking multi-way connectedness with con_check()","title":"Introduction to the 'connected' package","text":"two-way heatmaps previous section useful understand connectedness two factors, two factors? small example dataset Eccleston Russell (1975) three factors can represent 4x4 row-column experiment treatment cell. treatment codes letter number used previously-published scientific papers. treatment letter corresponds one number vice versa. Re-arranging treatments field layout rows columns useful: 4x4 grid completely filled, row column factors obviously connected. little bit study, can seen columns also connected via treatments. example treatment A1 appears columns 1 & 3, treatment B2 connects columns 3 & 2, D4 connects columns 2 & 4, C3 connects columns 4 & 1. connection treatments columns can checked formally con_check() function: vector 1s returned means observations dataframe connected group 1. Similarly, rows also connected via treatments. However, 3 factors considered time, completely disconnected observation belonging separate group. attempted fit linear model using 3 factors predictors, problems estimability. Another way examine stability model look reciprocal condition number model matrix, less machine precision, numerically singular.","code":"data_eccleston #>    row col trt #> 1    1   1  A1 #> 2    1   2  B2 #> 3    1   3  E5 #> 4    1   4  F6 #> 5    2   1  C3 #> 6    2   2  D4 #> 7    2   3  G7 #> 8    2   4  H8 #> 9    3   1  H8 #> 10   3   2  F6 #> 11   3   3  A1 #> 12   3   4  C3 #> 13   4   1  G7 #> 14   4   2  E5 #> 15   4   3  B2 #> 16   4   4  D4 ## library(reshape2) ## acast(data_eccleston, row~col, value.var='trt') ##    1  2  3  4  ##  1 A1 B2 E5 F6 ##  2 C3 D4 G7 H8 ##  3 H8 F6 A1 C3 ##  4 G7 E5 B2 D4 con_check(data_eccleston, ~ trt + col) #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> Levels: 1 # Here is how to add group membership to the data.  Or use cbind(). # data_eccleston %>% mutate(.grp = con_check(. , ~trt+col)) con_check(data_eccleston, ~ trt + row) #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> Levels: 1 con_check(data_eccleston, ~ trt + row + col) #>  [1] 16 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 #> Levels: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 set.seed(42) data_eccleston <- transform(data_eccleston,                             y = rnorm(nrow(data_eccleston), mean=100)) m1 <- lm(y ~ trt + row + col, data=data_eccleston) m1 #>  #> Call: #> lm(formula = y ~ trt + row + col, data = data_eccleston) #>  #> Coefficients: #> (Intercept)        trtB2        trtC3        trtD4        trtE5        trtF6   #>   100.78962     -0.18428     -0.11760      0.30450      0.20690     -0.72684   #>       trtG7        trtH8         row2         row3         row4         col2   #>    -0.22508     -0.50118     -0.06302      1.09660     -0.94338     -0.96532   #>        col3         col4   #>          NA      0.31332 X <- model.matrix(m1) rcond(X) #> [1] 1.311474e-17 .Machine$double.eps #> [1] 2.220446e-16"},{"path":"https://kwstat.github.io/connected/articles/introduction_to_the_connected_package.html","id":"improving-connectedness-with-con_filter","dir":"Articles","previous_headings":"","what":"Improving connectedness with con_filter()","title":"Introduction to the 'connected' package","text":"Sometimes two factors dataframe can weakly connected might want remove weak connections.","code":""},{"path":"https://kwstat.github.io/connected/articles/introduction_to_the_connected_package.html","id":"example-1","dir":"Articles","previous_headings":"Improving connectedness with con_filter()","what":"Example 1","title":"Introduction to the 'connected' package","text":"construct small example use tabyl function display data two-way table. two-way table easy see gen factor level G3 1 cell connecting state factor. might want eliminate column genotype G3. ordinary way use one approaches: generalize idea filtering new two-way filtering using con_filter() function. easiest way think function two-way table shown , define threshold minimum number connections two factors. example, might decide keep level gen appears least 2 states. use formula syntax . default, con_filter() function provides bit diagnostic information. filtering, notice state S3 appears decide want keep individual state least 2 gen.","code":"tab <- data.frame(gen=c(\"G1\",\"G1\",\"G1\",\"G1\", \"G2\",\"G2\",\"G2\", \"G3\"),                   state=c(\"S1\",\"S2\",\"S3\",\"S4\", \"S1\",\"S2\",\"S4\", \"S1\")) library(janitor) # For tabyl #>  #> Attaching package: 'janitor' #> The following objects are masked from 'package:stats': #>  #>     chisq.test, fisher.test tab %>% tabyl(state,gen) #>  state G1 G2 G3 #>     S1  1  1  1 #>     S2  1  1  0 #>     S3  1  0  0 #>     S4  1  1  0 subset(tab, gen != \"G3\") %>% tabyl(state,gen) #>  state G1 G2 #>     S1  1  1 #>     S2  1  1 #>     S3  1  0 #>     S4  1  1 dplyr::filter(tab, gen != \"G3\") %>% tabyl(state,gen) #>  state G1 G2 #>     S1  1  1 #>     S2  1  1 #>     S3  1  0 #>     S4  1  1 # Read this as \"2 state per gen\" tab2 <- con_filter(tab, ~ 2 * state / gen) #> Dropping these 1 of 3 levels of gen: #> [1] \"G3\" #> Deleted 1 of 8 rows of data. #> Warning in con_filter(tab, ~2 * state/gen): Some state have only 1 gen. tab2 %>% tabyl(state,gen) #>  state G1 G2 #>     S1  1  1 #>     S2  1  1 #>     S3  1  0 #>     S4  1  1 con_filter(tab2, ~ 2 * gen / state) %>% tabyl(state, gen) #> Dropping these 1 of 4 levels of state: #> [1] \"S3\" #> Deleted 1 of 7 rows of data. #>  state G1 G2 #>     S1  1  1 #>     S2  1  1 #>     S4  1  1"},{"path":"https://kwstat.github.io/connected/articles/introduction_to_the_connected_package.html","id":"example-2---missing-response-values","dir":"Articles","previous_headings":"Improving connectedness with con_filter()","what":"Example 2 - Missing response values","title":"Introduction to the 'connected' package","text":"R dataset OrchardSprays example Latin Square experiment 8 rows, 8 columns, 8 treatments. Suppose experiment, half response variable data lost. simulate : order visualize combinations rows columns still data, remove missing observations constructing table cell counts: con_filter() formula syntax can include response variable. response variable specified, data first filtered remove missing values response, two-way filtering performed. Suppose want least 2 observed values decrease row column desired result achieved.","code":"set.seed(42)   orch <- OrchardSprays   orch[runif(nrow(orch)) > .5 , \"decrease\"] <- NA   head(orch) #>   decrease rowpos colpos treatment #> 1       NA      1      1         D #> 2       NA      2      1         E #> 3        8      3      1         B #> 4       NA      4      1         H #> 5       NA      5      1         G #> 6       NA      6      1         F subset(orch, !is.na(decrease)) %>% tabyl(rowpos, colpos)  #>  rowpos 1 2 3 4 5 6 7 8 #>       1 0 0 0 1 1 1 0 0 #>       2 0 0 1 0 0 1 0 1 #>       3 1 1 1 1 1 1 1 1 #>       4 0 0 0 0 0 0 1 0 #>       5 0 0 0 1 1 1 1 0 #>       6 0 1 1 0 1 0 0 0 #>       7 0 1 0 0 0 0 1 0 #>       8 1 0 0 0 0 0 0 0 # Read: decrease has at least 2 colpos per rowps orch2 <- con_filter(orch, decrease ~ 2 * colpos / rowpos) #> Dropping these 2 of 8 levels of rowpos: #> [1] \"4\" \"8\" #> Deleted 2 of 25 rows of data. #> Warning in con_filter(orch, decrease ~ 2 * colpos/rowpos): Some colpos have #> only 1 rowpos. tabyl(orch2, rowpos, colpos) # Column 1 has only 1 observation #>  rowpos 1 2 3 4 5 6 7 8 #>       1 0 0 0 1 1 1 0 0 #>       2 0 0 1 0 0 1 0 1 #>       3 1 1 1 1 1 1 1 1 #>       5 0 0 0 1 1 1 1 0 #>       6 0 1 1 0 1 0 0 0 #>       7 0 1 0 0 0 0 1 0  # Read: decrease has at least 2 rowpos per colpos orch2 <- con_filter(orch2, decrease ~ 2 * rowpos / colpos) #> Dropping these 1 of 8 levels of colpos: #> [1] \"1\" #> Deleted 1 of 23 rows of data. tabyl(orch2, rowpos, colpos) #>  rowpos 2 3 4 5 6 7 8 #>       1 0 0 1 1 1 0 0 #>       2 0 1 0 0 1 0 1 #>       3 1 1 1 1 1 1 1 #>       5 0 0 1 1 1 1 0 #>       6 1 1 0 1 0 0 0 #>       7 1 0 0 0 0 1 0"},{"path":"https://kwstat.github.io/connected/articles/introduction_to_the_connected_package.html","id":"example-3---concatenating-two-factors","dir":"Articles","previous_headings":"Improving connectedness with con_filter()","what":"Example 3 - Concatenating two factors","title":"Introduction to the 'connected' package","text":"Sometimes might want combine two factors together filtering. Consider following example factor genotype gen, state, year. simulate random response data. shown previous sections, can check/filter gen:state gen:year factors, perhaps interested fitting model three-way interaction gen:state:year. One way trim type data combine state:year interaction single factor count number genotypes new factor. con_filter() function can perform concatenation two factors automatically using : operator. Looking results, can see column one level new state:year factor column least 2 genotypes, asked . ever want see data dropped filtering process, returndropped=TRUE argument can used.","code":"library(connected) library(janitor) test1 <- matrix( c(\"G1\", \"IA\", \"2020\", # gen has 1 state, 1 yr,                    \"G2\", \"IA\", \"2020\", # gen has 1 state, 2 yr                    \"G2\", \"IA\", \"2021\",                    \"G3\", \"NE\", \"2020\", # 2 states, 1 yr                    \"G3\", \"IA\", \"2020\",                    \"G4\", \"KS\", \"2020\", # state has 1 gen, 1 yr                    \"G5\", \"MO\", \"2020\", # state has 1 gen, 2yr                    \"G5\", \"MO\", \"2021\",                    \"G6\", \"IL\", \"2020\", # state has 2 gen, 1yr                    \"G7\", \"IL\", \"2020\",                    \"G8\", \"AR\", \"2019\", # year has 1 gen 1 state                    \"G9\", \"IN\", \"2018\", # year has 1 gen, 2 state                    \"G9\", \"OH\", \"2018\",                    \"G10\", \"MN\", \"2017\", # year has 2 gen, 1 state                    \"G11\", \"MN\", \"2017\",                    \"G12\", \"MD\", \"2010\", # gen has 2 state, 2 yr, 2 reps                    \"G12\", \"MD\", \"2010\",                    \"G12\", \"GA\", \"2011\",                    \"G12\", \"GA\", \"2011\"), byrow=TRUE, ncol=3) test1 <- as.data.frame(test1) colnames(test1) <- c(\"gen\",\"state\",\"year\")  set.seed(42) test1$y <- round( runif(nrow(test1)), 2) head(test1) #>   gen state year    y #> 1  G1    IA 2020 0.91 #> 2  G2    IA 2020 0.94 #> 3  G2    IA 2021 0.29 #> 4  G3    NE 2020 0.83 #> 5  G3    IA 2020 0.64 #> 6  G4    KS 2020 0.52 con_filter(test1, y ~ 2 * gen / state:year) |>   transform(stateyr=paste0(state,\"_\",year)) |>   tabyl(gen,stateyr) #> Dropping these 10 of 13 levels of state:year: #>  [1] \"AR2019\" \"GA2011\" \"IA2021\" \"IN2018\" \"KS2020\" \"MD2010\" \"MO2020\" \"MO2021\" #>  [9] \"NE2020\" \"OH2018\" #> Deleted 12 of 19 rows of data. #> Warning in con_filter(test1, y ~ 2 * gen/state:year): Some gen have only 1 #> state:year. #>  gen IA_2020 IL_2020 MN_2017 #>   G1       1       0       0 #>  G10       0       0       1 #>  G11       0       0       1 #>   G2       1       0       0 #>   G3       1       0       0 #>   G6       0       1       0 #>   G7       0       1       0 con_filter(test1, y ~ 2 * gen / state:year, returndropped=TRUE) #> Dropping these 10 of 13 levels of state:year: #>  [1] \"AR2019\" \"GA2011\" \"IA2021\" \"IN2018\" \"KS2020\" \"MD2010\" \"MO2020\" \"MO2021\" #>  [9] \"NE2020\" \"OH2018\" #> Deleted 7 of 19 rows of data. #> Warning in con_filter(test1, y ~ 2 * gen/state:year, returndropped = TRUE): #> Some gen have only 1 state:year. #>    gen state year    y #> 3   G2    IA 2021 0.29 #> 4   G3    NE 2020 0.83 #> 6   G4    KS 2020 0.52 #> 7   G5    MO 2020 0.74 #> 8   G5    MO 2021 0.13 #> 11  G8    AR 2019 0.46 #> 12  G9    IN 2018 0.72 #> 13  G9    OH 2018 0.93 #> 16 G12    MD 2010 0.94 #> 17 G12    MD 2010 0.98 #> 18 G12    GA 2011 0.12 #> 19 G12    GA 2011 0.47"},{"path":"https://kwstat.github.io/connected/articles/introduction_to_the_connected_package.html","id":"example-4-case-study-estimating-variance-components","dir":"Articles","previous_headings":"","what":"Example 4: Case study: Estimating variance components","title":"Introduction to the 'connected' package","text":"Sometimes observations dataset may connected, factor levels may weak connections might good idea remove weak connections. example, documentation ASRtrials package helpful analysis genotype--environment data, Gezan et al. (2022) write: “general, recommend minimum 5 genotypes common pair trials.” Ultimately, decide much connection want factors. following example shows use con_filter() function remove weak connections levels factors. plant breeding, one things people like look much variation data explained differences genotypes, years, locations, typically abbreviated GxYxL. order perform calculation, must least locations repeated across years. agridat package nice example dataset barley testing Minnesota. 6 locations across 49 years 235 different genotypes. 69090 combinations 3 factors, 2083 combinations yield values, great deal sparsity data. Nonetheless, can jump right try fit full mixed model combinations factors. analysis runs without obvious problems may perfectly acceptable, keeping mind comments connectedness , may want remove data two-way filtering. First, start two-way visualization sites years.  1893 1917, barley testing happened St. Paul site (near University Minnesota). Since possible explain much variation across locations 1 location, makes sense eliminate data years 1 site.  Looking across top, 1s tell us genotypes tested 1 year, really helping estimate variation across years decide drop .  considering genotypes spread across years, can also look genotypes spread across sites.  looking numbers across top axis, genotypes tested 1 site, drop .  check connectedness pair factors.    connectedness genotype year still bit weak, pairs factors good connections, try fit variance components model . lmer function fails converge, variance components look reasonable also asreml giving estimates (shown ), probably convergence criterion lmer quite satisfied essentially near maximum likelihood. Changing convergence criteria might helpful, can also try increasing connectedness genotype year, since noticed genotypes tested 2 years. Change require minimum 3 years testing: Now lmer converges without warnings. compare estimated variance parameters initial model m0 (n=2083 observations) model m1 final model m2 (n=1252 observations). CAUTION: VarCorr function re-orders terms output, careful combining two tables. biggest change variance components happens gen, decreases 46 9. particularly surprising. full dataset, genotypes tested trials. genotypes easily poorly performing regional check varieties serious candidates advancement testing. either case, genotypes variable genotypes data. speculating, based degree personal experience. thing note similarity variance parameters models m1 m2. similarity strengthens belief model m1 failed converge, likely near optimum likelihood.","code":"library(agridat) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union  dat0 <- agridat::minnesota.barley.yield if(nrow(dat0) < 2083) stop(\"Please update the agridat package.\") dat0 <- mutate(dat0, gen=factor(gen), site=factor(site), year=factor(year)) library(lme4) #> Loading required package: Matrix m0 <- lmer(yield ~ (1|gen) + (1|site) + (1|year) +               (1|gen:site) + (1|gen:year) + (1|site:year) + (1|gen:site:year),            data=dat0) summary(m0) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: yield ~ (1 | gen) + (1 | site) + (1 | year) + (1 | gen:site) +   #>     (1 | gen:year) + (1 | site:year) + (1 | gen:site:year) #>    Data: dat0 #>  #> REML criterion at convergence: 14327 #>  #> Scaled residuals:  #>      Min       1Q   Median       3Q      Max  #> -1.17872 -0.16019 -0.00281  0.16630  1.21505  #>  #> Random effects: #>  Groups        Name        Variance Std.Dev. #>  gen:site:year (Intercept) 24.6416  4.9640   #>  gen:year      (Intercept)  9.8795  3.1432   #>  gen:site      (Intercept)  0.8261  0.9089   #>  gen           (Intercept) 45.9856  6.7813   #>  site:year     (Intercept) 89.0064  9.4343   #>  year          (Intercept) 38.0930  6.1719   #>  site          (Intercept) 42.1995  6.4961   #>  Residual                   2.6587  1.6306   #> Number of obs: 2083, groups:   #> gen:site:year, 2079; gen:year, 1056; gen:site, 429; gen, 235; site:year, 164; year, 49; site, 6 #>  #> Fixed effects: #>             Estimate Std. Error t value #> (Intercept)   34.691      3.047   11.38  # Note, the asreml package gives the same estimates. # library(asreml) # m0a <- asreml(yield ~ 1, data=dat0, random  = ~ gen*site*year, workspace=\"1GB\") # lucid::lucid(summary(m0a)$varcomp) ##               component std.error z.ratio bound %ch ## site             42.2       29.1     1.45     P   0 ## year             38.1       15.7     2.42     P   0 ## gen              46          5.74    8.01     P   0 ## site:year        89         12.1     7.34     P   0 ## gen:site          0.826      0.55    1.5      P   0 ## gen:year          9.88       1.67    5.93     P   0 ## gen:site:year    24.6        2.32   10.6      P   0 ## units!R           2.66       1.88    1.41     P   0 # Keep the original data in dat0 and pruned data in dat1 dat1 <- dat0  con_view(dat1, yield~site*year, cluster=FALSE,          xlab=\"site\", ylab=\"year\", main=\"Minnesota Barley\") # Require 2 sites per year dat2 <- filter(dat1, !is.na(yield), n_distinct(site) >= 2, .by=year) dat1 <- con_filter(dat1, yield ~ 2*site/year) #> Dropping these 25 of 49 levels of year: #>  [1] \"1893\" \"1894\" \"1895\" \"1896\" \"1897\" \"1898\" \"1899\" \"1900\" \"1901\" \"1902\" #> [11] \"1903\" \"1904\" \"1905\" \"1906\" \"1907\" \"1908\" \"1909\" \"1910\" \"1911\" \"1912\" #> [21] \"1913\" \"1914\" \"1915\" \"1916\" \"1917\" #> Deleted 731 of 2083 rows of data. con_view(dat1, yield~gen*year, cluster=FALSE,          xlab=\"genotype\", ylab=\"year\") # Require 2 year per gen dat2 <- filter(dat2, n_distinct(year) >= 2, .by=gen) dat1 <- con_filter(dat1, yield~ 2*year/gen) #> Dropping these 15 of 62 levels of gen: #>  [1] \"241\"  \"244\"  \"558\"  \"611\"  \"2793\" \"2899\" \"2928\" \"4668\" \"4669\" \"7010\" #> [11] \"7011\" \"7012\" \"7013\" \"7014\" \"7015\" #> Deleted 50 of 1352 rows of data. con_view(dat1, yield~gen*year, cluster=FALSE, xlab=\"gen\", ylab=\"year\") con_view(dat1, yield~gen*site, cluster=FALSE, xlab=\"genotype\", ylab=\"site\") # Drop genotypes tested in only 1 site dat2 <- filter(dat2, n_distinct(site) >= 2, .by=gen) dat1 <- con_filter(dat1, yield~ 2*site/gen) #> Dropping these 10 of 47 levels of gen: #>  [1] \"531\"  \"835\"  \"912\"  \"915\"  \"923\"  \"1145\" \"2947\" \"3144\" \"4115\" \"4116\" #> Deleted 25 of 1302 rows of data. con_view(dat1, yield~gen*site, cluster=FALSE, xlab=\"genotype\", ylab=\"site\") con_view(dat1, yield ~ gen*site, cluster=FALSE, xlab=\"gen\", ylab=\"site\") con_view(dat1, yield ~ gen*year, cluster=FALSE, xlab=\"gen\", ylab=\"year\") con_view(dat1, yield ~ site*year, cluster=FALSE, xlab=\"site\", ylab=\"year\") library(lme4) m1 <- lmer(yield ~ (1|gen) + (1|site) + (1|year) +            (1|gen:site) + (1|gen:year) + (1|site:year) + (1|gen:site:year), data=dat1) summary(m1) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: yield ~ (1 | gen) + (1 | site) + (1 | year) + (1 | gen:site) +   #>     (1 | gen:year) + (1 | site:year) + (1 | gen:site:year) #>    Data: dat1 #>  #> REML criterion at convergence: 8434 #>  #> Scaled residuals:  #>      Min       1Q   Median       3Q      Max  #> -1.12837 -0.16942 -0.00168  0.17680  1.33933  #>  #> Random effects: #>  Groups        Name        Variance Std.Dev. #>  gen:site:year (Intercept) 21.971   4.687    #>  gen:year      (Intercept)  3.625   1.904    #>  gen:site      (Intercept)  1.280   1.132    #>  site:year     (Intercept) 87.412   9.349    #>  gen           (Intercept)  9.166   3.028    #>  year          (Intercept) 37.412   6.117    #>  site          (Intercept) 40.747   6.383    #>  Residual                   2.163   1.471    #> Number of obs: 1277, groups:   #> gen:site:year, 1274; gen:year, 285; gen:site, 187; site:year, 139; gen, 37; year, 24; site, 6 #>  #> Fixed effects: #>             Estimate Std. Error t value #> (Intercept)   36.751      3.055   12.03  # asreml converges to the same estimated values, so lmer is just finnicky # m1a <- asreml(yield ~ 1, data=dat1, random  = ~ gen*site*year, workspace=\"1GB\") # lucid::vc(m1a) # Require at least 3 year per genotype dat3 <- filter(dat1, n_distinct(year) >= 3, .by=gen) dat2 <- con_filter(dat1, yield ~ 3*year / gen) #> Dropping these 3 of 37 levels of gen: #> [1] \"1189\" \"1478\" \"5673\" #> Deleted 25 of 1277 rows of data. m2 <- lmer(yield ~ (1|gen) + (1|site) + (1|year) +              (1|gen:site) + (1|gen:year) + (1|site:year) + (1|gen:site:year),            data=dat2) summary(m2) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: yield ~ (1 | gen) + (1 | site) + (1 | year) + (1 | gen:site) +   #>     (1 | gen:year) + (1 | site:year) + (1 | gen:site:year) #>    Data: dat2 #>  #> REML criterion at convergence: 8281.1 #>  #> Scaled residuals:  #>      Min       1Q   Median       3Q      Max  #> -1.12068 -0.16831 -0.00262  0.17584  1.32712  #>  #> Random effects: #>  Groups        Name        Variance Std.Dev. #>  gen:site:year (Intercept) 22.114   4.703    #>  gen:year      (Intercept)  3.696   1.923    #>  gen:site      (Intercept)  1.272   1.128    #>  site:year     (Intercept) 87.468   9.352    #>  gen           (Intercept)  9.200   3.033    #>  year          (Intercept) 37.330   6.110    #>  site          (Intercept) 41.740   6.461    #>  Residual                   2.156   1.468    #> Number of obs: 1252, groups:   #> gen:site:year, 1249; gen:year, 279; gen:site, 173; site:year, 139; gen, 34; year, 24; site, 6 #>  #> Fixed effects: #>             Estimate Std. Error t value #> (Intercept)   36.912      3.084   11.97  # asreml gives the same estimated variance parameters. Not shown. # m2a <- asreml(yield ~ 1, data=dat2, random  = ~ gen*site*year, workspace=\"1GB\") # summary(m2a)$varcomp library(lucid) full_join( select(as.data.frame(VarCorr(m0)), grp, vcov),             select(as.data.frame(VarCorr(m1)), grp, vcov),             by=\"grp\", suffix=c(\".0\",\".1\")) %>%   full_join(select(as.data.frame(VarCorr(m2)), grp, vcov),             by=\"grp\", suffix=c(\".0\",\".2\")) %>% lucid #>             grp vcov.0 vcov.1  vcov #> 1 gen:site:year 24.6    22    22.1  #> 2      gen:year  9.88    3.63  3.7  #> 3      gen:site  0.826   1.28  1.27 #> 4           gen 46       9.17  9.2  #> 5     site:year 89      87.4  87.5  #> 6          year 38.1    37.4  37.3  #> 7          site 42.2    40.7  41.7  #> 8      Residual  2.66    2.16  2.16"},{"path":[]},{"path":"https://kwstat.github.io/connected/articles/introduction_to_the_connected_package.html","id":"how-to-extract-the-sorted-axis-tick-labels-from-the-levelplot","dir":"Articles","previous_headings":"Appendix - Infrequently Asked Questions","what":"1. How to extract the sorted axis tick labels from the levelplot","title":"Introduction to the 'connected' package","text":"want extract sorted axis tick labels, assign graphic object extract components interest:","code":"library(connected) dat <- data_fernando dat <- transform(dat, y = rnorm(nrow(dat))) tmp <- con_view(dat, y ~ gen*herd) #> Warning in con_view(dat, y ~ gen * herd): There are 2 groups tmp$x.limits[[1]] #> [1] \"G6\" \"G1\" \"G2\" \"G7\" \"G5\" \"G3\" \"G4\" tmp$y.limits[[1]] #> [1] \"H1\" \"H3\" \"H2\" \"H4\""},{"path":"https://kwstat.github.io/connected/articles/introduction_to_the_connected_package.html","id":"how-to-create-consistent-axis-tick-labels-across-multiple-datasets","dir":"Articles","previous_headings":"Appendix - Infrequently Asked Questions","what":"2. How to create consistent axis tick labels across multiple datasets","title":"Introduction to the 'connected' package","text":"user wanted axis tick labels across several different datasets, even though datasets might different factor levels. First create two small datasets. Note levels G2 E2 common datasets. Next, create reference dataframe contains factor levels dd1 dd2. Merge trait values dataframe. plotting, sure use dropNA=FALSE options factor levels without trait values kept use cluster=FALSE prevent re-ordering","code":"dd1 <- data.frame(x=rep(c(\"E1\",\"E2\"),2),                   y=rep(c(\"G1\",\"G2\"), each=2),                   z1=c(1,2,1.5,2.5)) dd2 <- data.frame(x=rep(c(\"E3\",\"E2\"),2),                   y=rep(c(\"G3\",\"G2\"), each=2),                   z2=c(3,4,3.5,4.5)) dd1 #>    x  y  z1 #> 1 E1 G1 1.0 #> 2 E2 G1 2.0 #> 3 E1 G2 1.5 #> 4 E2 G2 2.5 dd2 #>    x  y  z2 #> 1 E3 G3 3.0 #> 2 E2 G3 4.0 #> 3 E3 G2 3.5 #> 4 E2 G2 4.5 dd0 <- expand.grid(x=sort(unique(c(dd1$x, dd2$x))),                    y=sort(unique(c(dd1$y, dd2$y))) ) dd0 <- merge(dd0, dd1, by=c(\"x\",\"y\"), all.x=TRUE) dd0 <- merge(dd0, dd2, by=c(\"x\",\"y\"), all.x=TRUE) library(connected) con_view(dd0, z1 ~ x * y, cluster=FALSE, dropNA=FALSE, main=\"dd1\") con_view(dd0, z2 ~ x * y, cluster=FALSE, dropNA=FALSE, main=\"dd2\")"},{"path":"https://kwstat.github.io/connected/articles/introduction_to_the_connected_package.html","id":"how-to-view-the-axis-labels-andor-cell-group-numbers-when-there-are-many-levels","dir":"Articles","previous_headings":"Appendix - Infrequently Asked Questions","what":"3. How to view the axis labels and/or cell group numbers when there are many levels","title":"Introduction to the 'connected' package","text":"best strategy send graphical output pdf file experiment cex arguments con_view() reduce -plotting. open file good pdf viewer can zoom search text.","code":""},{"path":"https://kwstat.github.io/connected/articles/introduction_to_the_connected_package.html","id":"bibliography","dir":"Articles","previous_headings":"","what":"Bibliography","title":"Introduction to the 'connected' package","text":"Eccleston, J. K. Russell (1975). Connectedness orthogonality multi-factor designs. Biometrika, 62, 341-345. https://doi.org/10.1093/biomet/62.2.341 Fernando, Rohan D. Gianola M. Grossman (1983). Identifying Connected Subsets Two-Way Classification Without Interaction. J. Dairy Science, 66, 1399-1402. Table 1. https://doi.org/10.3168/jds.S0022-0302(83)81951-1 Gezan, Salvador . Giovanni Galli Darren Murray (2022). User’s Manual ASRtriala v. 1.0.0. Published VSNi. https://vsni.co.uk/resources/free-software/asrtriala/ Piepho, Hans-Peter. (1994) Missing observations analysis stability. Heredity, 72, 141–145. https://doi.org/10.1038/hdy.1994.20","code":""},{"path":"https://kwstat.github.io/connected/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kevin Wright. Author, maintainer.","code":""},{"path":"https://kwstat.github.io/connected/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wright K (2025). connected: Visualize Improve Connectedness Factors Tables. R package version 1.1, https://kwstat.github.io/connected/.","code":"@Manual{,   title = {connected: Visualize and Improve Connectedness of Factors in Tables},   author = {Kevin Wright},   year = {2025},   note = {R package version 1.1},   url = {https://kwstat.github.io/connected/}, }"},{"path":"https://kwstat.github.io/connected/index.html","id":"connected-","dir":"","previous_headings":"","what":"Visualize and Improve Connectedness of Factors in Tables","title":"Visualize and Improve Connectedness of Factors in Tables","text":"Homepage: https://kwstat.github.io/connected Repository: https://github.com/kwstat/connected Tools visualize improve connectedness factors data","code":""},{"path":"https://kwstat.github.io/connected/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key features","title":"Visualize and Improve Connectedness of Factors in Tables","text":"Consistent function design: con_check(data, y ~ + B) - Identify connected groups factors. con_concur(data, y ~ / B) - Plot concurrence matrix two factors. con_filter(data, y ~ 2 * / B) - Perform 2-factor filtering data. Provide verbose output (similar tidylog package). con_view(data, y ~ + B) - View 2-way heatmap factors, identify connected groups. missing values response variable y, observations missing values deleted.","code":""},{"path":"https://kwstat.github.io/connected/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Visualize and Improve Connectedness of Factors in Tables","text":"","code":"# Install the released version from CRAN: install.packages(\"connected\")  # Install the development version from GitHub: install.packages(\"devtools\") devtools::install_github(\"kwstat/connected\")"},{"path":"https://kwstat.github.io/connected/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Visualize and Improve Connectedness of Factors in Tables","text":"Check connectedness multiple factors dataframe: Visualize connectedness two factors. cells “1” cells “2” two disjoint groups. Improve connectedness two factors two-way filtering View concurrence matrix two factors","code":"library(connected)  # The 'class' and 'student' factors are disconnected in 2 groups R> con_check(data_student, test1 ~ class + student) # [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 library(connected) con_view(data_student, test1~student*class, main=\"test1\", xlab=\"student\", ylab=\"class\") library(connected) library(janitor) # For tabyl  data_student |>    tabyl(student,class) # student art chem hort math phys weld #       A   1    1    0    1    1    0 #       B   2    1    0    1    1    0 #       C   1    1    0    1    1    0 #       D   1    1    0    1    1    0 #       E   1    0    0    0    0    0 #       F   0    1    0    1    1    0 #       G   0    1    0    1    1    0 #       H   0    1    0    1    1    0 #       I   0    1    0    1    1    0 #       J   1    1    0    0    1    0 #       K   1    1    0    1    1    0 #       L   0    0    1    0    0    1 #       M   0    0    1    0    0    1  con_filter(data_student, test1 ~ 7*student/class) |>   tabyl(student,class) # Dropping these 3 of 6 levels of class: # [1] \"art\"  \"hort\" \"weld\" # Deleted 11 of 35 rows of data. # student chem math phys #       A    1    1    1 #       B    1    1    1 #       C    1    1    1 #       F    1    1    1 #       G    1    1    1 #       H    1    1    1 #       I    1    1    1 #       J    1    0    1 #       K    0    1    0 # Warning message: # In con_filter(data_student, test1 ~ 7 * student/class) : #   Some student have only 1 class. # Number of concurrent students for each pair of classes con_concur(data_student, test1 ~ student/ class)"},{"path":"https://kwstat.github.io/connected/reference/con_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Check connectedness of multiple factors in a dataframe — con_check","title":"Check connectedness of multiple factors in a dataframe — con_check","text":"Multiple factors dataframe said connected model matrix based factors full rank. function provides formula interface lfe::compfactor() function check connectedness factors.","code":""},{"path":"https://kwstat.github.io/connected/reference/con_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check connectedness of multiple factors in a dataframe — con_check","text":"","code":"con_check(data = NULL, formula = NULL, WW = TRUE, dropNA = TRUE)"},{"path":"https://kwstat.github.io/connected/reference/con_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check connectedness of multiple factors in a dataframe — con_check","text":"data dataframe formula formula multiple factor names dataframe, like y ~ f1 + f2 + f3 WW Pass-argument compfactor dropNA TRUE, observed data NA dropped.","code":""},{"path":"https://kwstat.github.io/connected/reference/con_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check connectedness of multiple factors in a dataframe — con_check","text":"vector integers representing group membership observation.","code":""},{"path":"https://kwstat.github.io/connected/reference/con_check.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Check connectedness of multiple factors in a dataframe — con_check","text":"None","code":""},{"path":"https://kwstat.github.io/connected/reference/con_check.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check connectedness of multiple factors in a dataframe — con_check","text":"Kevin Wright","code":""},{"path":"https://kwstat.github.io/connected/reference/con_check.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check connectedness of multiple factors in a dataframe — con_check","text":"","code":"# In the data_eccleston dataframe, each pair of factors is connected. con_check(data_eccleston, ~ row + trt) #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> Levels: 1 con_check(data_eccleston, ~ col + trt) #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> Levels: 1 con_check(data_eccleston, ~ row + col) #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> Levels: 1 # But all three factors are COMPLETELY disconnected into 16 groups. con_check(data_eccleston, ~ row + col + trt) #>  [1] 16 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 #> Levels: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16"},{"path":"https://kwstat.github.io/connected/reference/con_concur.html","id":null,"dir":"Reference","previous_headings":"","what":"View concurrence of two factors in a dataframe using a matrix plot. — con_concur","title":"View concurrence of two factors in a dataframe using a matrix plot. — con_concur","text":"Draws concurrence plot 2 factors dataframe. example, multi-environment yield trial (testing multiple crop varieties multple environments) interesting examine balance testing pattern. pair environments, many genotypes tested environments? concurrence plot shows amount connectedness (number varieties) environments . default, missing values response deleted. Replicated combinations two factors ignored. (changed someone need.)","code":""},{"path":"https://kwstat.github.io/connected/reference/con_concur.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"View concurrence of two factors in a dataframe using a matrix plot. — con_concur","text":"","code":"con_concur(   data,   formula,   dropNA = TRUE,   xlab = \"\",   ylab = \"\",   cex.x = 0.7,   cex.y = 0.7,   ... )"},{"path":"https://kwstat.github.io/connected/reference/con_concur.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"View concurrence of two factors in a dataframe using a matrix plot. — con_concur","text":"data dataframe formula formula multiple factor names dataframe, like y ~ f1 / f2. dropNA TRUE, observed data NA dropped. xlab Label x axis ylab Label y axis cex.x Scale factor x axis tick labels.  Default 0.7. cex.y Scale factor y axis tick labels  Default 0.7. ... parameters passed levelplot() function.","code":""},{"path":"https://kwstat.github.io/connected/reference/con_concur.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"View concurrence of two factors in a dataframe using a matrix plot. — con_concur","text":"lattice graphics object","code":""},{"path":"https://kwstat.github.io/connected/reference/con_concur.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"View concurrence of two factors in a dataframe using a matrix plot. — con_concur","text":"None","code":""},{"path":"https://kwstat.github.io/connected/reference/con_concur.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"View concurrence of two factors in a dataframe using a matrix plot. — con_concur","text":"Kevin Wright","code":""},{"path":"https://kwstat.github.io/connected/reference/con_concur.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"View concurrence of two factors in a dataframe using a matrix plot. — con_concur","text":"","code":"require(lattice) #> Loading required package: lattice bar = transform(lattice::barley, env=factor(paste(site,year))) set.seed(123) bar <- bar[sample(1:nrow(bar), 70, replace=TRUE),] con_concur(bar, yield ~ variety / env, cex.x=0.75, cex.y=.3)"},{"path":"https://kwstat.github.io/connected/reference/con_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter a dataframe using two-way criteria to increase connectedness — con_filter","title":"Filter a dataframe using two-way criteria to increase connectedness — con_filter","text":"Traditional filtering (subsetting) data typically performed via criteria based columns data. contrast, function performs filtering data based joint rows columns matrix-view two factors. Conceptually, idea re-shape two three columns dataframe matrix, delete entire rows (columns) matrix many missing cells row (column). two useful applications two-way filtering : Remove factor level interactions another factor. especially useful linear models remove rare factor combinations. Remove factor level missing interactions another factor. especially useful biplots matrix remove rows columns missing values. formula syntax used specify two-way filtering criteria. examples may provide easiest understanding. dat <- data.frame(state=c(\"NE\",\"NE\", \"IA\", \"NE\", \"IA\"), year=c(1,2,2,3,3), value=11:15) 'value' column re-shaped matrix looks like: state/year |  1 |  2 |  3 | NE | 11 | 12 | 14 | IA |    | 13 | 15 | Drop states much missing combinations. Keep states \"least 3 years per state\" con_filter(dat, ~ 3 * year / state) NE    1    11 NE    2    12 NE    3    14 Keep years \"least 2 states per year\" con_filter(dat, ~ 2 * state / year) NE    2    12 IA    2    13 NE    3    14 IA    3    15 constant number formula less 1.0, interpreted fraction. Keep states \"least 75% years per state\" con_filter(dat, ~ .75 * year / state) possible include another factor either side slash \"/\". Suppose data another factor political party called \"party\". Keep states \"least 2 combinations party:year per state\" con_filter(dat, ~ 2 * party:year / state) formula contains response variable, missing values dropped first, two-way filtering based factor combinations. con_filter(dat, value ~ 2 * state / year)","code":""},{"path":"https://kwstat.github.io/connected/reference/con_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter a dataframe using two-way criteria to increase connectedness — con_filter","text":"","code":"con_filter(data, formula, verbose = TRUE, returndropped = FALSE)"},{"path":"https://kwstat.github.io/connected/reference/con_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter a dataframe using two-way criteria to increase connectedness — con_filter","text":"data dataframe formula formula two factor names dataframe specifies criteria filtering, like y ~ 2 * f1 / f2 verbose TRUE, print diagnostic information data deleted. (Similar 'tidylog' package). returndropped TRUE, return dropped rows instead kept rows. Default FALSE.","code":""},{"path":"https://kwstat.github.io/connected/reference/con_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter a dataframe using two-way criteria to increase connectedness — con_filter","text":"original dataframe returned, minus rows filtered .","code":""},{"path":"https://kwstat.github.io/connected/reference/con_filter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Filter a dataframe using two-way criteria to increase connectedness — con_filter","text":"None.","code":""},{"path":"https://kwstat.github.io/connected/reference/con_filter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Filter a dataframe using two-way criteria to increase connectedness — con_filter","text":"Kevin Wright","code":""},{"path":"https://kwstat.github.io/connected/reference/con_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter a dataframe using two-way criteria to increase connectedness — con_filter","text":"","code":"dat <- data.frame(   gen = c(\"G3\", \"G4\", \"G1\", \"G2\", \"G3\", \"G4\", \"G5\",           \"G1\", \"G2\", \"G3\", \"G4\", \"G5\",           \"G1\", \"G2\", \"G3\", \"G4\", \"G5\",           \"G1\", \"G2\", \"G3\", \"G4\", \"G5\"),   env = c(\"E1\", \"E1\", \"E1\", \"E1\", \"E1\", \"E1\", \"E1\",           \"E2\", \"E2\", \"E2\", \"E2\", \"E2\",           \"E3\", \"E3\", \"E3\", \"E3\", \"E3\",           \"E4\", \"E4\", \"E4\", \"E4\", \"E4\"),   yield = c(65, 50, NA, NA, 65, 50, 60,             NA, 71, 76, 80, 82,             90, 93, 95, 102, 97,             98, 102, 105, 130, 135))  # How many observations are there for each combination of gen*env? with( subset(dat, !is.na(yield)) , table(gen,env) ) #>     env #> gen  E1 E2 E3 E4 #>   G1  0  0  1  1 #>   G2  0  1  1  1 #>   G3  2  1  1  1 #>   G4  2  1  1  1 #>   G5  1  1  1  1  # Note, if there is no response variable, the two-way filtering is based # only on the presence of the factor combinations. dat1 <- con_filter(dat, ~ 4*env / gen) #> Deleted 0 of 22 rows of data.  # If there is a response variable, missing values are dropped first, # then the two-way filtering is based on the factor combinations.  dat1 <- con_filter(dat, yield ~ 4*env/gen) #> Dropping these 2 of 5 levels of gen: #> [1] \"G1\" \"G2\" #> Deleted 5 of 19 rows of data. dat1 <- con_filter(dat, yield ~ 5*env/ gen) #> Dropping these 5 of 5 levels of gen: #> [1] \"G1\" \"G2\" \"G3\" \"G4\" \"G5\" #> Deleted 19 of 19 rows of data. #> Warning: No data remains. dat1 <- con_filter(dat, yield ~ 6*gen/ env) #> Dropping these 4 of 4 levels of env: #> [1] \"E1\" \"E2\" \"E3\" \"E4\" #> Deleted 19 of 19 rows of data. #> Warning: No data remains. dat1 <- con_filter(dat, yield ~ .8 *env / gen) #> Dropping these 2 of 5 levels of gen: #> [1] \"G1\" \"G2\" #> Deleted 5 of 19 rows of data. dat1 <- con_filter(dat, yield ~ .8* gen / env) #> Dropping these 1 of 4 levels of env: #> [1] \"E1\" #> Deleted 5 of 19 rows of data. dat1 <- con_filter(dat, yield ~ 7 * env / gen) #> Dropping these 5 of 5 levels of gen: #> [1] \"G1\" \"G2\" \"G3\" \"G4\" \"G5\" #> Deleted 19 of 19 rows of data. #> Warning: No data remains."},{"path":"https://kwstat.github.io/connected/reference/con_view.html","id":null,"dir":"Reference","previous_headings":"","what":"View connectedness of two factors in a dataframe using a levelplot — con_view","title":"View connectedness of two factors in a dataframe using a levelplot — con_view","text":"replication treatment combination cells two-way table, replications averaged together (counted) constructing heatmap. default, rows columns clustered using 'incidence' matrix 0s 1s. function checks see cells heatmap form connected set.  , data divided connected subsets subset group number shown within cell. default, missing values response deleted. Factor levels shown along left bottom sides. number cells column/row shown along top/right sides. 2 factors disconnected, group membership ID shown cell.","code":""},{"path":"https://kwstat.github.io/connected/reference/con_view.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"View connectedness of two factors in a dataframe using a levelplot — con_view","text":"","code":"con_view(   data,   formula,   fun.aggregate = mean,   xlab = \"\",   ylab = \"\",   cex.num = 0.75,   cex.x = 0.7,   cex.y = 0.7,   col.regions = RedGrayBlue,   cluster = \"incidence\",   dropNA = TRUE,   ... )"},{"path":"https://kwstat.github.io/connected/reference/con_view.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"View connectedness of two factors in a dataframe using a levelplot — con_view","text":"data dataframe formula formula two () factor names dataframe like yield ~ f1 *f2 fun.aggregate function use aggregating data cells. Default mean. xlab Label x axis ylab Label y axis cex.num Disjoint group number. cex.x Scale factor x axis tick labels.  Default 0.7. cex.y Scale factor y axis tick labels  Default 0.7. col.regions Function color regions. Default RedGrayBlue. cluster \"incidence\", cluster rows columns incidence matrix. FALSE, clustering performed. dropNA TRUE, observed data NA dropped. ... parameters passed levelplot() function.","code":""},{"path":"https://kwstat.github.io/connected/reference/con_view.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"View connectedness of two factors in a dataframe using a levelplot — con_view","text":"lattice graphics object","code":""},{"path":"https://kwstat.github.io/connected/reference/con_view.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"View connectedness of two factors in a dataframe using a levelplot — con_view","text":"Kevin Wright","code":""},{"path":"https://kwstat.github.io/connected/reference/con_view.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"View connectedness of two factors in a dataframe using a levelplot — con_view","text":"","code":"require(lattice) bar = transform(lattice::barley, env=factor(paste(site,year))) set.seed(123) bar <- bar[sample(1:nrow(bar), 70, replace=TRUE),] con_view(bar, yield ~ variety * env, cex.x=1, cex.y=.3, cluster=FALSE)   # Create a heatmap of cell counts w2b = colorRampPalette(c('wheat','black')) con_view(bar, yield ~ variety * env, fun.aggregate=length,   cex.x=1, cex.y=.3, col.regions=w2b, cluster=FALSE)   # Example from paper by Fernando et al. (1983). set.seed(42) data_fernando = transform(data_fernando,   y=stats::rnorm(9, mean=100)) con_view(data_fernando, y ~ gen*herd, cluster=FALSE,      main = \"Fernando unsorted\") #> Warning: There are 2 groups  con_view(data_fernando, y ~ gen*herd, cluster=TRUE,      main = \"Fernando unsorted\") #> Warning: There are 2 groups   # Example from Searle (1971), Linear Models, p. 325 dat2 = transform(data_searle,   y=stats::rnorm(nrow(data_searle)) + 100)  con_view(dat2, y ~ f1*f2, cluster=FALSE, main=\"data_searle unsorted\")  #> Warning: There are 3 groups  con_view(dat2, y ~ f1*f2, main=\"data_searle clustered\") #> Warning: There are 3 groups"},{"path":"https://kwstat.github.io/connected/reference/data_eccleston.html","id":null,"dir":"Reference","previous_headings":"","what":"Data from Eccleston & Russell — data_eccleston","title":"Data from Eccleston & Russell — data_eccleston","text":"Data Eccleston & Russell","code":""},{"path":"https://kwstat.github.io/connected/reference/data_eccleston.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data from Eccleston & Russell — data_eccleston","text":"","code":"data_eccleston"},{"path":"https://kwstat.github.io/connected/reference/data_eccleston.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data from Eccleston & Russell — data_eccleston","text":"object class data.frame 16 rows 3 columns.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_eccleston.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Data from Eccleston & Russell — data_eccleston","text":"Eccleston, J. K. Russell (1975). Connectedness orthogonality multi-factor designs. Biometrika, 62, 341-345. https://doi.org/10.1093/biomet/62.2.341","code":""},{"path":"https://kwstat.github.io/connected/reference/data_eccleston.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data from Eccleston & Russell — data_eccleston","text":"dataframe 3 treatment factors. pair factors connected, 3 factors disconnected. 'trt' column uses numbers match Eccleston (Table 1, Design 1) letters match Foulley (Table 13.3).","code":""},{"path":"https://kwstat.github.io/connected/reference/data_eccleston.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Data from Eccleston & Russell — data_eccleston","text":"Foulley, J. L., Bouix, J., Goffinet, B., & Elsen, J. M. (1990). Connectedness Genetic Evaluation. Advanced Series Agricultural Sciences, 277–308. https://doi.org/10.1007/978-3-642-74487-7_13","code":""},{"path":"https://kwstat.github.io/connected/reference/data_eccleston.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data from Eccleston & Russell — data_eccleston","text":"","code":"# Each pair of factors is connected con_check(data_eccleston, ~ row + trt) #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> Levels: 1 con_check(data_eccleston, ~ col + trt) #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> Levels: 1 con_check(data_eccleston, ~ row + col) #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> Levels: 1 # But all three factors are COMPLETELY disconnected con_check(data_eccleston, ~ row + col + trt) #>  [1] 16 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 #> Levels: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  set.seed(42) data_eccleston <- transform(data_eccleston,   y = rnorm(nrow(data_eccleston), mean=100)) con_view(data_eccleston, y ~ row*col, xlab=\"row\", ylab=\"col\")  con_view(data_eccleston, y ~ row*trt, xlab=\"row\", ylab=\"trt\")  con_view(data_eccleston, y ~ col*trt, xlab=\"col\", ylab=\"trt\")"},{"path":"https://kwstat.github.io/connected/reference/data_fernando.html","id":null,"dir":"Reference","previous_headings":"","what":"Data from Fernando et al. — data_fernando","title":"Data from Fernando et al. — data_fernando","text":"Data Fernando et al.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_fernando.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data from Fernando et al. — data_fernando","text":"","code":"data_fernando"},{"path":"https://kwstat.github.io/connected/reference/data_fernando.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data from Fernando et al. — data_fernando","text":"object class data.frame 9 rows 2 columns.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_fernando.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Data from Fernando et al. — data_fernando","text":"Fernando et al. (1983). Identifying Connected Subsets Two-Way Classification Without Interaction. J. Dairy Science, 66, 1399-1402. Table 1. https://doi.org/10.3168/jds.S0022-0302(83)81951-1","code":""},{"path":"https://kwstat.github.io/connected/reference/data_fernando.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data from Fernando et al. — data_fernando","text":"dataframe 2 treatment factors. treatment combinations form 2 disconnected groups.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_fernando.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data from Fernando et al. — data_fernando","text":"","code":"library(lfe) #> Loading required package: Matrix cbind(data_fernando,       .group=con_check(data_fernando, ~ gen + herd)) #>   gen herd .group #> 1  G2   H1      2 #> 2  G1   H1      2 #> 3  G1   H3      2 #> 4  G6   H3      2 #> 5  G3   H2      1 #> 6  G4   H2      1 #> 7  G5   H2      1 #> 8  G5   H4      1 #> 9  G7   H4      1 library(connected) set.seed(42) data_fernando = transform(data_fernando,   y=stats::rnorm(9, mean=100)) con_view(data_fernando, y ~ gen*herd, cluster=FALSE,   main = \"Fernando unsorted\") #> Warning: There are 2 groups  con_view(data_fernando, y ~ gen*herd, main=\"Fernando clustered\") #> Warning: There are 2 groups"},{"path":"https://kwstat.github.io/connected/reference/data_searle.html","id":null,"dir":"Reference","previous_headings":"","what":"Data from Searle — data_searle","title":"Data from Searle — data_searle","text":"Data Searle","code":""},{"path":"https://kwstat.github.io/connected/reference/data_searle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data from Searle — data_searle","text":"","code":"data_searle"},{"path":"https://kwstat.github.io/connected/reference/data_searle.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data from Searle — data_searle","text":"object class data.frame 14 rows 2 columns.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_searle.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Data from Searle — data_searle","text":"Searle (1971). Linear Models. Page 324.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_searle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data from Searle — data_searle","text":"dataframe 2 treatment factors. treatment combinations form 3 disconnected groups.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_searle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data from Searle — data_searle","text":"","code":"cbind(data_searle,       .group=con_check(data_searle, ~ f1 + f2)) #>    f1 f2 .group #> 1   1  1      3 #> 2   2  3      1 #> 3   2  4      1 #> 4   3  2      2 #> 5   3  6      2 #> 6   4  1      3 #> 7   4  5      3 #> 8   4  7      3 #> 9   5  3      1 #> 10  5  4      1 #> 11  6  3      1 #> 12  6  4      1 #> 13  7  2      2 #> 14  7  6      2 data_searle = transform(data_searle,   y = rnorm(nrow(data_searle), mean=100)) con_view(data_searle, y ~ f1*f2, cluster=FALSE, main=\"Searle unsorted\") #> Warning: There are 3 groups  con_view(data_searle, y ~ f1*f2, main=\"Searle clustered\") #> Warning: There are 3 groups"},{"path":"https://kwstat.github.io/connected/reference/data_student.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Data of Student Test Scores — data_student","title":"Simulated Data of Student Test Scores — data_student","text":"Simulated Data Student Test Scores","code":""},{"path":"https://kwstat.github.io/connected/reference/data_student.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Data of Student Test Scores — data_student","text":"","code":"data(\"data_student\")"},{"path":"https://kwstat.github.io/connected/reference/data_student.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated Data of Student Test Scores — data_student","text":"data frame 41 observations following 4 variables. student student ID class class/subject test1 score test 1 test2 score test 2","code":""},{"path":"https://kwstat.github.io/connected/reference/data_student.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulated Data of Student Test Scores — data_student","text":"simulated data imagines following scenario: school, 12 students (-M) tested 6 classes (math, chemistry,   physics, art, horticulture, welding). students enrolled classes. class, students given test 1, later test 2.   Test scores 0-100. (Using 2 tests typical learning assessment, measuring   intervention effectiveness, comparison test forms, etc.) students missed class day test score   test. Student B felt ill art test 1 allowed re-take test 1   (test 1 scores included test 2 score used).","code":""},{"path":"https://kwstat.github.io/connected/reference/data_student.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Simulated Data of Student Test Scores — data_student","text":"None","code":""},{"path":"https://kwstat.github.io/connected/reference/data_student.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulated Data of Student Test Scores — data_student","text":"None","code":""},{"path":"https://kwstat.github.io/connected/reference/data_student.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulated Data of Student Test Scores — data_student","text":"","code":"data(data_student)"},{"path":"https://kwstat.github.io/connected/reference/data_tosh.html","id":null,"dir":"Reference","previous_headings":"","what":"Data from Tosh — data_tosh","title":"Data from Tosh — data_tosh","text":"Data Tosh","code":""},{"path":"https://kwstat.github.io/connected/reference/data_tosh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data from Tosh — data_tosh","text":"","code":"data_tosh"},{"path":"https://kwstat.github.io/connected/reference/data_tosh.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data from Tosh — data_tosh","text":"object class data.frame 15 rows 3 columns.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_tosh.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Data from Tosh — data_tosh","text":"Tosh, J. J., J. W. Wilton. (1990). Degree connectedness mixed models. Proceedings 4th World Congress Genetics applied Livestock Production, 480-483. Page 481.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_tosh.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data from Tosh — data_tosh","text":"dataframe 3 treatment factors. treatment combinations form 2 disconnected groups.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_tosh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data from Tosh — data_tosh","text":"","code":"cbind(data_tosh,       .group=con_check(data_tosh, ~ a + b + c)) #>    a b c .group #> 1  1 1 1      1 #> 2  1 1 6      1 #> 3  1 2 1      1 #> 4  1 2 2      1 #> 5  1 2 4      1 #> 6  2 1 1      1 #> 7  2 1 6      1 #> 8  2 2 2      1 #> 9  2 2 6      1 #> 10 1 3 3      2 #> 11 1 3 5      2 #> 12 1 4 3      2 #> 13 2 3 3      2 #> 14 2 3 5      2 #> 15 2 4 5      2 data_tosh = transform(data_tosh,   y = rnorm(nrow(data_tosh), mean=100)) library(connected) con_view(data_tosh, y ~ b * c) #> Warning: There are 2 groups"},{"path":"https://kwstat.github.io/connected/reference/data_weeks1.html","id":null,"dir":"Reference","previous_headings":"","what":"Data from Weeks & Williams example 1 — data_weeks1","title":"Data from Weeks & Williams example 1 — data_weeks1","text":"Data Weeks & Williams example 1","code":""},{"path":"https://kwstat.github.io/connected/reference/data_weeks1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data from Weeks & Williams example 1 — data_weeks1","text":"","code":"data_weeks1"},{"path":"https://kwstat.github.io/connected/reference/data_weeks1.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data from Weeks & Williams example 1 — data_weeks1","text":"object class data.frame 16 rows 3 columns.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_weeks1.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Data from Weeks & Williams example 1 — data_weeks1","text":"Weeks, David L. & Donald R. Williams (1964). Note Determination Connectedness N-Way Cross Classification. Technometrics, 6:3, 319-324. Table 1. http://dx.doi.org/10.1080/00401706.1964.10490188","code":""},{"path":"https://kwstat.github.io/connected/reference/data_weeks1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data from Weeks & Williams example 1 — data_weeks1","text":"dataframe 3 treatment factors. treatment combinations connected. Note: data based Table 1 Weeks & Williams. Table 2 missing treatment combination (1,2,4).","code":""},{"path":"https://kwstat.github.io/connected/reference/data_weeks1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data from Weeks & Williams example 1 — data_weeks1","text":"","code":"library(lfe) cbind(data_weeks1,       .group=con_check(data_weeks1, ~ f1+f2+f3)) #>    f1 f2 f3 .group #> 1   1  1  2      1 #> 2   1  1  3      1 #> 3   1  1  4      1 #> 4   1  2  1      1 #> 5   1  2  2      1 #> 6   1  2  4      1 #> 7   1  3  1      1 #> 8   1  3  2      1 #> 9   1  3  4      1 #> 10  2  1  2      1 #> 11  2  1  4      1 #> 12  2  2  1      1 #> 13  2  2  3      1 #> 14  2  2  4      1 #> 15  2  3  1      1 #> 16  2  3  4      1"},{"path":"https://kwstat.github.io/connected/reference/data_weeks2.html","id":null,"dir":"Reference","previous_headings":"","what":"Data from Weeks & Williams example 2 — data_weeks2","title":"Data from Weeks & Williams example 2 — data_weeks2","text":"Data Weeks & Williams example 2","code":""},{"path":"https://kwstat.github.io/connected/reference/data_weeks2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data from Weeks & Williams example 2 — data_weeks2","text":"","code":"data_weeks2"},{"path":"https://kwstat.github.io/connected/reference/data_weeks2.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data from Weeks & Williams example 2 — data_weeks2","text":"object class data.frame 62 rows 3 columns.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_weeks2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Data from Weeks & Williams example 2 — data_weeks2","text":"Weeks, David L. & Donald R. Williams (1964). Note Determination Connectedness N-Way Cross Classification. Technometrics, 6:3, 319-324. Table 3. http://dx.doi.org/10.1080/00401706.1964.10490188","code":""},{"path":"https://kwstat.github.io/connected/reference/data_weeks2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data from Weeks & Williams example 2 — data_weeks2","text":"dataframe 3 treatment factors. treatment combinations form 4 disconnected groups. Note: data based Table 3 Weeks & Williams. groups defined text missing combinations.","code":""},{"path":"https://kwstat.github.io/connected/reference/data_weeks2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data from Weeks & Williams example 2 — data_weeks2","text":"","code":"library(lfe) cbind(data_weeks2,       .group=con_check(data_weeks2, ~f1 + f2 + f3)) #>    f1 f2 f3 .group #> 1   2  2  2      4 #> 2   4  2  2      4 #> 3   2  2  4      4 #> 4   4  2  4      4 #> 5   2  4  2      4 #> 6   4  4  2      4 #> 7   2  4  4      4 #> 8   4  4  4      4 #> 9   2  1  1      1 #> 10  2  1  3      1 #> 11  2  1  5      1 #> 12  2  3  1      1 #> 13  2  3  3      1 #> 14  2  3  5      1 #> 15  2  5  1      1 #> 16  2  5  3      1 #> 17  2  5  5      1 #> 18  4  1  1      1 #> 19  4  1  3      1 #> 20  4  1  5      1 #> 21  4  3  1      1 #> 22  4  3  3      1 #> 23  4  3  5      1 #> 24  4  5  1      1 #> 25  4  5  3      1 #> 26  4  5  5      1 #> 27  1  2  1      2 #> 28  1  2  3      2 #> 29  1  2  5      2 #> 30  1  4  1      2 #> 31  1  4  3      2 #> 32  1  4  5      2 #> 33  3  2  1      2 #> 34  3  2  3      2 #> 35  3  2  5      2 #> 36  3  4  1      2 #> 37  3  4  3      2 #> 38  3  4  5      2 #> 39  5  2  1      2 #> 40  5  2  3      2 #> 41  5  2  5      2 #> 42  5  4  1      2 #> 43  5  4  3      2 #> 44  5  4  5      2 #> 45  1  1  2      3 #> 46  1  1  4      3 #> 47  1  3  2      3 #> 48  1  3  4      3 #> 49  1  5  2      3 #> 50  1  5  4      3 #> 51  3  1  2      3 #> 52  3  1  4      3 #> 53  3  3  2      3 #> 54  3  3  4      3 #> 55  3  5  2      3 #> 56  3  5  4      3 #> 57  5  1  2      3 #> 58  5  1  4      3 #> 59  5  3  2      3 #> 60  5  3  4      3 #> 61  5  5  2      3 #> 62  5  5  4      3"},{"path":"https://kwstat.github.io/connected/news/index.html","id":"connected-11-","dir":"Changelog","previous_headings":"","what":"connected 1.1 ()","title":"connected 1.1 ()","text":"New function con_concur suggested E.Tanaka.","code":""},{"path":"https://kwstat.github.io/connected/news/index.html","id":"connected-10-20250204","dir":"Changelog","previous_headings":"","what":"connected 1.0 (2025.02.04)","title":"connected 1.0 (2025.02.04)","text":"Initial CRAN submission. License GPL3 S.Callistein.","code":""},{"path":"https://kwstat.github.io/connected/news/index.html","id":"connected-01-2024-06-01","dir":"Changelog","previous_headings":"","what":"connected 0.1 (2024-06-01)","title":"connected 0.1 (2024-06-01)","text":"con_filter() function began life minPer() sometime 2012-01-01. con_view() function began heat() 2013-01-01.","code":""}]
